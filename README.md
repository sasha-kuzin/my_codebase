# Здесь я пишу свой С++ код 

## Оглавление

0. [Зачем я пишу здесь код?](#Зачем-я-пишу-здесь-код)
1. [Что за код я здесь пишу?](#Что-за-код-я-здесь-пишу)
2. [Что за код лежит в репозитории сейчас?](#Что-за-код-лежит-в-репозитории-сейчас)
    1. [NonogrammSolver](#NonogrammSolver)
    2. [NonogrammSolver(beta)](#NonogramSolver)

## Зачем я пишу здесь код?
В этом году я закончил бакалавриат по специальности **"Математическое обеспечение и администрирование информационных систем"** и ищу **стажировку/работу**.
В процессе учебы занялся спортивным программированием, участвую в **ICPC-соревнованиях**, а также контестах на платформе **[codeforces](https://codeforces.com/profile/WoodMachine)**.

Также, помимо учебы в ВУЗе, проходил различные курсы, например [Искусство разработки на современном С++](https://www.coursera.org/specializations/c-plus-plus-modern-development).

В данном репозитории я размещаю и поддерживаю различный С++ в качестве портфолио. 

[:arrow_up:Оглавление](#Оглавление)
____

## Что за код я здесь пишу?
- Закрепление идей, техник, паттернов и приемов, изученных мной ранее.
- Реализация определенных алгоритмов (в университете программировал системы поддержки принятия решений, системы ИИ и хочу переосмыслить их с учетом возросших знаний языка программирования).
- Интересные задачи, которые попали на соревнованиях по программированию.

[:arrow_up:Оглавление](#Оглавление)
____

## Что за код лежит в репозитории сейчас?
### NonogrammSolver 
*Это alpha-версия. По итогам написания кода был составлен список архитектурных и алгоритмических недочетов, которые будут учтены при написании второй версии*
<details>
<summary> Описание игры под катом... </summary>
<b>NonogrammSolver</b> - это программа для решения головоломки <b>nonogram</b> (https://en.wikipedia.org/wiki/Nonogram). Данная головоломка показалась мне довольно занимательной, 
и у меня довольно быстро родилась пара идей алгоритмов, решающих данную головоломку самостоятельно.

Если коротко, то игра заключается в построении "изображения" по информации о количестве последовательных блоков из закрашенных клеток на игровом поле:

![Alt-текст](https://lh3.googleusercontent.com/XzsNE2Ebu9emJmEd5vZ9JnOW10Dusa_3dWuT3bMDE8kasgnR-78M8lO8h87DzA6cTrvA=h500 "Нонограм")
</details>
Код программы разбит на следуюшие модули:

- **Parser**. Предназначен для интерпретации входных данных и построения базы решения. Принимает на вход наборы строк, описывающих игровое поле (в уже решенном состоянии), а также маску, 
которая определяет, какая часть головоломки будет изначально видна на игровом поле. Также отвечает за валидацию входных данных.

    Парсер содержит единственную структуру данных: *ParserResponse*, в конструктор которой помещается игровое поле и маска. Структура содержит код ошибки и базу решения:

```C++
struct ParserResponse {
		ErrorMsg error;
		std::optional <DecisionBase::DecisionBase> decision_base; 
		explicit ParserResponse(const std::vector<std::string>& game_board, const std::vector<std::string>& mask);
	};
```

- **DecisionBase**. Содержит игровое поле, маску, а также шифрует блоки игрового поля в набор чисел, описывающих их положения (как на рисунке выше) в каждой строке и каждом столбце.
Также реализован класс *DecisionBaseBuilder*, для упрощения создания экземпляров DecisionBase, т.к. его конструктор имеет много входных параметров.

    Описание класса *DecisionBaseBuilder*. Здесь реализована идиома *chaining* для удобного создания экземпляров DecisionBase.

```C++
template <typename T>
using Matrix = std::vector<std::vector<T>>;

class DecisionBase;

class DecisionBaseBuilder {
		size_t size;
		Matrix<bool> game_board;
		Matrix<bool> mask;
	public:
		DecisionBaseBuilder& SetSize(std::size_t);
		DecisionBaseBuilder& SetGameBoard(const Matrix<bool>&);
		DecisionBaseBuilder& SetMask(const Matrix<bool>&);

		DecisionBaseBuilder& SetGameBoard(Matrix<bool>&&);
		DecisionBaseBuilder& SetMask(Matrix<bool>&&);

		DecisionBase Build();
	};
  
  Matrix<bool> ConvertBoardFromStrings(const std::vector<std::string>& strings, char sym_true);

  auto decision_base = DecisionBaseBuilder()
				.SetSize(mask.size())
				.SetGameBoard(ConvertBoardFromStrings(game_board, '*'))
				.SetMask(ConvertBoardFromStrings(mask, '*'))
				.Build();
 ```
 
 - **Solver**. Конструктор данного класса принимает экземпляр DecisionBase, используя в нем маскированное поле и шифр игровых блоков. Метод 'Solve()' 
 строит решение на основе этих данных и обновляет статус задачи. Запросив статус задачи можно узнать, в какой стадии находится решение головоломки.
 
     Поиск решения происходит итеративно, путем перебора решений с отсечениями. Ключевой момент алгоритма - перебор возможных на данном этапе решений, отсекая те, которые не удовлятворяют текущей маске.
     Отобранные решения побитово накладываются друг на друга, после чего можно определить те поля игрового поля, которые будут пустыми или окрашенными при *любом* из оставшихся возможных решений.
 
     Каждая итерация, соотвественно, сужает список возможных решений, пока не останется единственное. Если единственного решения не будет, статус задачи будет UNSOLVED.
     
     Описание итерации поиска решения:
     
     ```C++
     bool Solver::Row::DistillateSolutions() {
		std::set<int> old_solutions = move(solutions);
		int colored_mask = (1 << game_row.size()) - 1;
		int empty_mask = 0;
		for (auto solution : old_solutions) {
			if (ValidateSolution(solution, game_row)) {
				solutions.insert(solution);
				colored_mask &= solution;
				empty_mask |= solution;
			}
		}

		bool result_flag = false;
		for (auto i = 0; i < game_row.size(); ++i) {

			int checker = (1 << i);

			if ((colored_mask & checker) == checker) {
				if (game_row[i] == -1) {
					result_flag = true;
					game_row[i] = 1;
				}
				else if (game_row[i] == 0) {
					throw new std::invalid_argument("Gameboard has a conflict");
				}
			}

			if ((empty_mask & checker) == 0) {
				if (game_row[i] == -1) {
					result_flag = true;
					game_row[i] = 0;
				}
				else if (game_row[i] == 1) {
					throw new std::invalid_argument("Gameboard has a conflict");
				}
			}
		}

		return result_flag;
	}
     ```
- **Юнит-тесты** распределны по разным .cpp файлам, проверяют корректность работы всех модулей.

**P.S** Также я добавил еще один конструктор для Solver:

```C++
Solver(size_t size, Matrix<int> horizontal,Matrix<int> vertical);
```

Дело в том, что полный цикл работы программы подразумевает решенную головоломку, которая шифруется в *DecisionBase*, а затем разгадывается в *Solver*. 
Это требует составления головоломок вручную или ручное решение готовых задач.

Так как мне лень было решать большие головоломки вручную, этот конструктор используется для решения задачи **без** заранее готового решения. 

[:arrow_up:Оглавление](#Оглавление)
____

### NonogrammSolver(beta)

Чем будет отличаться данная версия от описанной выше:
- [ ] функционал. Программа в качестве входных данных должна принимать только маску и зашифрованное положение блоков.
- [ ] архитектура. Для данной программы отлично подходит паттерн "Конвейер", который и будет реализован.
- [ ] выходные данные. В отличие от предыдущей версии, которая определяла отсутствие **одного** решения как отсутствие решения **в целом**, данная версия программы будет строить
все возможные решения.
- [ ] работа с входными данными. В дополнение к сырому потоку ввода или определенного вектора строк логично использовать JSON.
- [ ] реализация в виде .dll
- [ ] любые другие идеи, полученные в процессе дальнейшего обучения

[:arrow_up:Оглавление](#Оглавление)
____

### Следующий проект (To be announced...)
